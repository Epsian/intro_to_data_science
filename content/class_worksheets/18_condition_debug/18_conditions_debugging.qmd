---
pre: <b>10/19. </b>
title: "Debugging and Conditions"
weight: 18
summary: "Tools to fix errors and test conditions."
format:
    hugo:
      toc: true
      output-file: "_index.en.md"
      reference-links: true
      code-link: true
      
---

```{r, include=FALSE}
answers = FALSE
```

## Overview

Code will hardly ever work exactly as you want the first try. Especially early on, coding is an exercise in incremental improvements. Debugging, or identifying and removing "buggy" code that doesn't work as intended, is the skill that lets us identify what is wrong so we can make those improvements.

Today's worksheet is presented as a series of puzzles. Each puzzle will be a function that has something wrong with it. I will provide an input, and the desired output. Your task is to use the debugging tools we learned to figure out what is wrong with the function, and correct it. I will walk through an example first so you get the idea.

## Our Toolbox

We will be using two main tools for debugging, `debugonce()` and `browser()`. Each accomplishes the same thing is slightly different ways. These functions let you pause the execution of code mid-way inside a function, and see what is going inside our mini-R universes. This is very helpful, as opposed to just running code in your global environment, you can't normally run code inside a function line-by-line to see what is happening to the data at each step. `debugonce()` and `browser()` let you do that. This is also very helpful while building new functions.

`debugonce()` accepts a function name, and the next time you run a function, it will drop you into the mini-universe of that function for you to look around. You can tell it worked because your console will change slightly.

![](img/browser.png)

The figure above shows what the browser window will look like. While in the browser, you can execute R code like normal, but there are a few differences.

1. Instead of the regular `>` prompt in the R console, you will see `Browse[#]>` indicating you are in the *browser*. It still works mostly like the normal console, with a few extra commands.</br>
&nbsp;&nbsp;&nbsp;&nbsp;a) You can press `Enter` or enter the letter `n` to go to the next line of code.</br>
&nbsp;&nbsp;&nbsp;&nbsp;b) You can enter `c` to continue to the end of the function</br>
&nbsp;&nbsp;&nbsp;&nbsp;c) You can enter `q` to quit and leave the browser
2. The script pane is replaced with a function inspector walking you through the function you are debugging. You normally can't type in this window. The current line, what will be executed next time you press enter or `n` is highlighted.
3. A few new buttons show up. These are the same as the commands described in #1.

## Debugging Example

Here is an example function that needs some debugging. This one is relatively short, and you may be able to figure out the problem without debugging. This will not always be the case, as function will routinely extend for a dozen or several dozen lines, with multiple other function inside of them creating nested mini-universes. The debugging process will always be the same though: figure out what function the problem is in, then go inside and follow the process step-by-step.

This function is meant to accept a numeric vector, and then output the mean, median, and mode. Instead, it results in the error shown below.

```{r}
#| error: true

example_vector = c(1, 2, 6, 8, 4, 2, 8, 2, 7, 10, 33)

example_function = function(num_vec) {
  
  # get the mean
  vec_mean = mean(num_vec)
  
  # get the median
  vec_median = median(num_vec)
  
  # get the mode
  vec_mode = mode(num_vec)
  
  # create named vector for output
  output = c("mean" = vec_mean, "median" = vec_median, "mode" = vec_mode)
  
  # make sure all results are numeric
  if(!all(is.numeric(output))){stop("Not all values are numeric!")}
  
  # return results
  return(output)
}

example_function(example_vector)
```

How would we go about fixing this? We only have one function, so we know where things must be going wrong. We'll use `debugonce()` to get a peak inside. Copy the above function code into your console and execute it to add the function to your environment. Run the function on `example_vector` to make sure you are getting the same output as we did here. Once you have done that, run `debugonce(example_function)`, then run `example_function(example_vector)` again. You will be dropped into the debugger.





Return the wrong value


“TRUE”


Sum a logical?


do something with gsub working on the whoel dataframe rather than a vector


pivot someting so that the long form is all character for value then look for TRUES or do math


use a conditional to make a function safe


